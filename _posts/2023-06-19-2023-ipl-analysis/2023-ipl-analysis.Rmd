---
title: "2023 IPL Analysis"
description: |
  Who were the best batters and bowlers in the 2023 IPL? I use Adjusted Run Rate and Adjusted Average to examine the season's performances.
author:
  - name: Seth Benson
    url: https://example.com/norajones
date: 2023-06-19
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


The 2023 IPL concluded at the end of last month. With over 70 games played (and at least 14 per team), it provided a large sample size to judge player performance. But how should these performances be judged and what is the best way to evaluate how much a player benefits their team in the t20 franchise games? The most traditional form is just aggregate stats, tracking the total runs over the tournament will [tell you](https://www.crictracker.com/ipl-orange-cap/) that Shubman Gill had the best performance of batsmen. Likewise, subjective awards like [Team of the Tournament](https://www.espncricinfo.com/story/ipl-2023-team-of-tournament-shubman-gill-suryakumar-yadav-mohammed-shami-ravindra-jadeja-in-the-mix-1379113) can be used. But a rigorous evaluation metric requires both objectivity and nuanced analysis that goes beyond these two forms. Especially for franchise performance, few metrics like this exist, and those that do are often less than transparent about their methods.  

So what's the alternative? I'm presenting Adjusted Run Rate and Adjusted Average as new methods to gauge how much players helped or hurt their team. The metrics were inspired by [this ESPNcricinfo article](https://www.espncricinfo.com/story/ipl-2020-how-many-wins-do-the-top-players-contribute-to-their-team-in-an-ipl-season-1236781) which presented their own Runs Above Average metric that has unfortunately to my knowledge not been updated or expanded upon since then. I present what I believe is an improvement on their metric with my Adjusted Run Rate and introduce a way of evaluating the effect of staying longer at the crease or taking wickets with the Adjusted Average metric. This is done by taking weighing a player's strike rate/economy and average by the overs they bat/bowl in, the venue they are playing at, and position they face. Below you will see how different players fared according to the metric followed by a more in-depth explanation of how they are calculated.

First, how efficiently did different batsmen score in the tournament? This is where batting Adjusted Run Rate (ARR) is used. Simply put, ARR measures how much more or less runs per ball a batter produces than would be expected. An 'expected' score is calculated for each ball they face by using the average runs scored in the venue and over they are in and adjusting for the quality of the bowler they are facing. So a batter with an ARR of 0 would be batting at an exactly average rate, while a batter with an ARR of 0.1 would be producing one tenth of a run per ball more than what would be expected. Below you can see how all batters that scored at least 100 runs did on this metric graphed alongside their economy (note: dot size reflects total runs scored). When adjusting for betting situations, you can see that some players with similar strike rates have very different Adjusted Run Rates. For example, Kyle Mayers (0.175 ARR), who primarily batted in earlier overs with a lower expected run rate, had a much higher Adjusted Run Rate than Andre Russell (-0.113 ARR), even though Russell had a higher strike rate. However, strike rate and ARR are still largely correlated. Glen Maxwell and Rashid Khan had the top two Adjusted Run Rates in the tournament while also having two of the top three strike rates.

```{r batting ARR}
library(tidyr)
library(dplyr)
#bat_data <- read.csv('../../Data/IPL/2023/bat_data.csv')
bat_data <- read.csv('Data/IPL/2023/bat_data.csv')
#colnames(bat_data)
bat_data <- bat_data %>% filter(runs > 100)
library(plotly)
fig <- plot_ly(type = 'scatter', mode = 'markers') 
fig_bat <- fig %>%
  add_trace(
    x=bat_data$strike_rate, 
    y=bat_data$adj_avg_bat_rd,
    text = paste(bat_data$striker, format(bat_data$adj_avg_bat_rd,digits=3)),
    hoverinfo = 'text',
    marker = list(size = bat_data$runs, sizeref = 1.5, sizemode = 'area', color='blue'),
    showlegend = F
  ) %>%
  layout(title = 'IPL 2023 Batting Efficiency',  xaxis = list(title = 'Economy'), 
         yaxis = list(title = 'Adjusted Run Rate'))
fig_bat
```

The same metric can be used to judge how economical bowlers were. Bowling Adjusted Run Rate (ARR) is calculated just like batting ARR except it examines the runs conceded by a bowler. So, like economy, a lower number is better. A bowler with a -0.1 ARR concedes one tenth of a run per ball less than expected. Below is the ARR and economy for all bowlers that bowled at least 100 balls in the 2023 IPL with dot size scaled by balls bowled. Like batting ARR and strike rate, we can see that bowling ARR is highly correlated with economy. Ravichandran Ashwin had the lowest ARR of the season among qualified bowlers while also having one of the lowest economies. There are some outliers though, such as Jofra Archer, who had a much better than average average ARR (-0.162) despite conceding nine and a half runs an over. This reflects the fact that he frequently face above average batters throughout the season. 

```{r bowling ARR}
library(tidyr)
library(dplyr)
#bat_data <- read.csv('../../Data/IPL/2023/bat_data.csv')
bowl_data <- read.csv('Data/IPL/2023/bowl_data.csv')
#colnames(bat_data)
bowl_data <- bowl_data %>% filter(balls > 100)
library(plotly)
fig <- plot_ly(type = 'scatter', mode = 'markers') 
fig_bowl <- fig %>%
  add_trace(
    x=bowl_data$econ, 
    y=bowl_data$adj_avg_bowl_rd,
    text = paste(bowl_data$bowler, format(bowl_data$adj_avg_bowl_rd,digits=3)),
    hoverinfo = 'text',
    marker = list(size = bowl_data$balls, sizeref = 1.5, sizemode = 'area', color='green'),
    showlegend = F
  ) %>% 
  layout(title = 'IPL 2023 Bowling Efficiency',  xaxis = list(title = 'Economy'), 
         yaxis = list(title = 'Adjusted Run Rate'))
fig_bowl

```

However, scoring rate is not the only way a player can impact their team's performance. While wickets have less of an impact on t20 than other forms of the game, batters that can stay at the crease longer and bowlers that can take more wickets help their put their teams in a position to win. The Adjusted Average metric calculates this impact after adjusting for a player's situation. This is calculated very similarly to ARR, where each ball a batter faces or bowler bowls receives an expected average determined by the venue, over, and opposition. Then, a players Adjusted Average is determined by difference between their actual average and the mean expected average of balls they faced/bowled. This metric is shown below for both batters and bowlers performance compared to their simple average. For batting, it most heavily rewards batters that had high averages despite frequently batting in middle or late overs where more wickets are typically taken. Adjusted Average for bowlers is much more correlated with Average than for batters. This is likely due to the fact that, while some bowlers may be more used at the beginning of an inning or during death overs, bowlers overall play in a higher variety of overs than batters. Most teams emply a mixed bowling attack rather than having their bowlers stay on to use all for of their overs at once.

```{r Average}
library(tidyr)
library(dplyr)
#bat_data <- read.csv('../../Data/IPL/2023/bat_data.csv')
bat_data <- read.csv('Data/IPL/2023/bat_data.csv')
#colnames(bat_data)
bat_data <- bat_data %>% filter(runs > 100)
library(plotly)
fig <- plot_ly(type = 'scatter', mode = 'markers') 
fig_bat <- fig %>%
  add_trace(
    x=bat_data$bat_average, 
    y=bat_data$bowl_adj_bat_avg,
    text = paste(bat_data$striker, format(bat_data$bowl_adj_bat_avg,digits=3)),
    hoverinfo = 'text',
    marker = list(size = bat_data$runs, sizeref = 1.5, sizemode = 'area', color='blue'),
    showlegend = F
  ) %>%
  layout(title = 'IPL 2023 Batting Average vs Adjusted Average',  xaxis = list(title = 'Average'), 
         yaxis = list(title = 'Adjusted Average'))
fig_bat


bowl_data <- read.csv('Data/IPL/2023/bowl_data.csv')
#colnames(bat_data)
bowl_data <- bowl_data %>% filter(balls > 100)
fig <- plot_ly(type = 'scatter', mode = 'markers') 
fig_bowl <- fig %>%
  add_trace(
    x=bowl_data$bowl_average, 
    y=bowl_data$bat_adj_bowl_avg,
    text = paste(bowl_data$bowler, format(bowl_data$bat_adj_bowl_avg,digits=3)),
    hoverinfo = 'text',
    marker = list(size = bowl_data$balls, sizeref = 1.5, sizemode = 'area', color='green'),
    showlegend = F
  ) %>% 
  layout(title = 'IPL 2023 Bowling Average vs Adjusted Average',  xaxis = list(title = 'Average'), 
         yaxis = list(title = 'Adjusted Average'))
fig_bowl
```

Overall, these metrics should serve as starting points for a deeper experimentation with quantifying player performance in cricket. The continued expansion of the t20 game across many franchise leagues makes it particularly prone for expended analysis, in fact I believe the t20 game holds the potential for growing statistical analysis on par with the advanced analytics movement in baseball. An important next step is creating a cohesive player performance metric that combines Adjusted Run Rate and Adjusted Average. Additionally, more elements could be included to build a more inclusive breakdown of player situation (such as how many wickets are lost in an inning). 